{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/abacus.js","webpack:///./src/abacusCtrl.js","webpack:///./src/bead.js","webpack:///./src/index.js","webpack:///./src/ui.js"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;AClFA,mBAAmB,mBAAO,CAAC,yCAAc;AACzC,kBAAkB,mBAAO,CAAC,yBAAM;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,I;;AAEA;AACA;AACA;AACA;AACA;AACA,gFAAgF;AAChF;;AAEA;AACA,iBAAiB,EAMV;AACP;;AAEA;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+D;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,EAuCV;;AAEP;AACA;AACA;AACA,qBAAqB,8BAA8B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB,+BAA+B;AACpD;AACA;AACA;AACA;AACA;AACA,wBAAwB,iCAAiC;AACzD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;;AAEA,cAAc;AACd;;AAEA;AACA;;AAEA;;;;;;;;;;;;AChTA,aAAa,mBAAO,CAAC,6BAAQ;;AAE7B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,mBAAmB;AACpC,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6CAA6C;AAC7C,6CAA6C;;AAE7C;AACA;;AAEA,cAAc;AACd;;AAEA;AACA;AACA;;AAEA,kCAAkC;AAClC,kBAAkB,qBAAqB;AACvC,sCAAsC;AACtC,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4B;;;;;;;;;;;AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mFAAmF;AACnF;AACA;AACA;;AAEA;;;;;;;;;;;;ACnGA,eAAe,mBAAO,CAAC,iCAAU;;AAEjC;AACA;AACA;AACA,CAAC,E;;;;;;;;;;;ACLD;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;;AAEA","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","const AbacusCtrl = require(\"./abacusCtrl\");\nconst UIElement = require(\"./ui\");\n\nclass Abacus {\n   constructor(parentDivId, type) {\n      this.abacusCtrl = new AbacusCtrl(type, 8);\n      this.canvas;\n      this.divId = parentDivId;\n      this.beadColor = \"rgba(133, 178, 255, 1.0)\";\n      this.hooveredBeadColor = \"rgba(170, 215, 255, 1.0)\";\n      this.hooveredElement = -1;\n      this.hooveredBead = -1;\n      this.uiElements = new Array();\n      this.that = this;\n   }\n\n   drawBead(beadId, ctx) {\n      // draw bead\n\t\tlet bead = this.abacusCtrl.beads[beadId];\n\t\t\n      // let beadPosX = bead.getBeadPositionX(beadId);\n\t\t// let beadPosY = bead.getBeadPositionY(beadId);\n\t\t\n\t\tlet beadPosX = bead.posX;\n\t\tlet beadPosY = bead.posY;\n\n\n      let dn = new UIElement(\n         beadPosX,\n         beadPosY + 2,\n         bead.width,\n         bead.height - 4,\n         0,\n         beadId\n      );\n\n      // draw the shadow\n      ctx.fillStyle = \"rgba(60, 60, 60, 0.3)\";\n      bead.drawRoundRectFilled(\n         ctx,\n         dn.x + 4,\n         dn.y + 4,\n         dn.x2 - dn.x,\n         dn.y2 - dn.y,\n         15\n\t\t);\t\t\t\t\t\t\n\n      // draw the shape\n      ctx.fillStyle = this.beadColor;\n      if (bead.isHoovered) {\n         ctx.fillStyle = HOOVERED_BEAD_COLOR;\n      }\n      bead.drawRoundRectFilled(ctx, dn.x, dn.y, dn.x2 - dn.x, dn.y2 - dn.y, 15); // draw the blue filling\n      ctx.fillStyle = \"rgba(255, 255, 255, 1.0)\";\n\n      this.uiElements.push(dn);\n      if (false) {\n         ctx.fillStyle = \"rgba(0, 0, 0, 1.0)\";\n         ctx.textAlign = \"left\";\n         ctx.font = \"10pt sans-serif\";\n         ctx.fillText(\"ID: \" + beadId, dn.x + 4, dn.y2 - 13);\n         ctx.lineWidth = 1;\n      }\n   }\n\n   drawBeads(ctx) {\n      let count = this.abacusCtrl.getBeadsCount();\n      for (let i = 0; i < count; i++) {\n         this.drawBead(i, ctx);\n      }\n   }\n\n   init() {\n      this.abacusCtrl.init();\n      this.canvas = document.createElement(\"canvas\");\n      if (!this.canvas)\n         console.log(\"Abacus error: your browser does not support HTML Canvas\");\n      let beadHeight = this.abacusCtrl.beadHeight;\n      this.canvas.id = this.divId + \"_abacus\";\n      this.canvas.width =\n\t\t\t40 + this.abacusCtrl.beadRods * this.abacusCtrl.beadSpacing;\t\t\n      this.canvas.height =\n         60 + (this.abacusCtrl.beadPerRod + 2) * this.abacusCtrl.beadHeight;\n\n      document.body.appendChild(this.canvas);\n      let parent = document.getElementById(this.divId);\n\n      if (!parent)\n         console.log(\n            \"Abacus error: can not find the element with the \" +\n               this.divId +\n               \"name\"\n         );\n\n      parent.appendChild(this.canvas);\n\n      this.canvas.onmousedown = event => {\n         canvasMouseDown(event);\n      };\n\n      this.canvas.onmousemove = event => {\n         canvasMouseMove(event);\n      };\n\n      this.canvas.onmouseup = event => {\n         canvasMouseUp(event);\n      };\n\n      this.canvas.onmouseup = event => {\n         canvasMouseUp(event);\n      };\n\n      this.update();\n   }\n\n   update() {\n      this.uiElements.length = 0;\n      let ctx = this.canvas.getContext(\"2d\");\n      ctx.strokeStyle = \"#000000\";\n\n      // draw grid\n      if (false) {\n         ctx.strokeStyle = \"#808080\";\n\n         let stepsX = 20.0 - 0.0;\n         let stepsY = 20.0 - 0.0;\n         let lx = 0 % stepsX;\n         let ly = 0 % stepsY;\n         let Lx = 0 % (stepsX * 5.0);\n         if (Lx < 0.0) Lx += stepsX * 5.0;\n         let Ly = 0 % (stepsY * 5.0);\n         if (Ly < 0.0) Ly += stepsY * 5.0;\n\n         while (lx < this.canvas.width) {\n            if (Math.abs(Lx - lx) < 0.001) {\n               ctx.strokeStyle = \"#404040\";\n               Lx += stepsX * 5.0;\n            } else {\n               ctx.strokeStyle = \"#808080\";\n            }\n            ctx.beginPath();\n            ctx.moveTo(lx, 0);\n            ctx.lineTo(lx, canvas.height);\n            ctx.stroke();\n            lx += stepsX;\n         }\n\n         while (ly < this.canvas.height) {\n            if (Math.abs(Ly - ly) < 0.001) {\n               ctx.strokeStyle = \"#404040\";\n               Ly += stepsY * 5.0;\n            } else {\n               ctx.strokeStyle = \"#808080\";\n            }\n            ctx.beginPath();\n            ctx.moveTo(0, ly);\n            ctx.lineTo(canvas.width, ly);\n            ctx.stroke();\n            ly += stepsY;\n         }\n      }\n\n      // draw frame\n      ctx.strokeStyle = \"#000000\";\n      ctx.lineWidth = 5;\n      for (let i = 0; i < this.abacusCtrl.beadRods; i++) {\n         let x =\n            -30 +\n            this.abacusCtrl.beadRods * this.abacusCtrl.beadSpacing -\n            i * this.abacusCtrl.beadSpacing;\n         let y =\n            20 + (this.abacusCtrl.beadPerRod + 2) * this.abacusCtrl.beadHeight;\n         ctx.beginPath();\n         ctx.moveTo(x, 20);\n         ctx.lineTo(x, y);\n         ctx.stroke();\n      }\n      for (let j = 0; j < 3; j++) {\n         let y = 20;\n         if (j === 1)\n            y =\n               20 +\n               (this.abacusCtrl.beadPerRod - this.abacusCtrl.beadSep) *\n                  this.abacusCtrl.beadHeight;\n         if (j === 2)\n            y =\n               20 +\n               (this.abacusCtrl.beadPerRod + 2) * this.abacusCtrl.beadHeight;\n         ctx.beginPath();\n         ctx.moveTo(20, y);\n         ctx.lineTo(640, y);\n         ctx.stroke();\n      }\n      ctx.lineWidth = 1;\n\n      // draws all beads\n      this.drawBeads(ctx);\n\n      // draw value\n      ctx.fillStyle = \"rgba(0, 0, 0, 1.0)\";\n      ctx.textAlign = \"center\";\n      ctx.font = \"20pt sans-serif\";\n      let textY = 50 + (this.beadPerLine + 2) * this.abacusCtrl.beadHeight;\n      for (let i = 0; i < this.abacusCtrl.beadLines; i++) {\n         let textX =\n            -30 +\n            this.abacusCtrl.beadLines * this.abacusCtrl.beadSpacing -\n            i * this.abacusCtrl.beadSpacing;\n         let valueSum = 0;\n         for (let j = 0; j < this.abacusCtrl.beadPerLine; j++) {\n            let n = i * this.abacusCtrl.beadPerLine + j;\n            if (this.abacusCtrl.beads[n].active) {\n               valueSum += this.abacusCtrl.beads[n].value;\n            }\n         }\n\n         let valueSting;\n         if (this.abacusCtrl.type === 0) {\n            valueSting = valueSum.toString(10);\n         } else {\n            valueSting = valueSum.toString(16);\n         }\n\n         ctx.fillText(valueSting, textX, textY);\n      }\n   }\n\n   mouseOverElement(pos) {\n      let selectedElement = -1;\n      for (let n in this.uiElements) {\n         if (this.uiElements[n].type !== 2) {\n            // not of type \"connection\"\n            if (\n               this.uiElements[n].x - 1 < pos.x &&\n               this.uiElements[n].x2 + 1 > pos.x &&\n               this.uiElements[n].y - 1 < pos.y &&\n               this.uiElements[n].y2 + 1 > pos.y\n            ) {\n               selectedElement = n;\n            }\n         }\n      }\n      return selectedElement;\n   }\n\n   canvasMouseDown(event) {\n      var pos = this.getMouse(event);\n\n      // handle selection\n      if (!event.altKey && event.which === 1) {\n         var selectedElement = this.mouseOverElement(pos);\n         if (selectedElement !== -1) {\n            // handle node selection\n            if (this.uiElements[selectedElement].type === 0) {\n               var newSelectedBead = this.uiElements[selectedElement].ref;\n               this.abacusCtrl.activated(newSelectedBead);\n            }\n         }\n         that.update();\n      }\n      event.preventDefault();\n   }\n\n   canvasMouseUp(event) {}\n\n   canvasMouseMove(event) {\n      let pos = this.getMouse(event);\n\n      hooveredBead = -1;\n      let oldHooveredElement = hooveredElement;\n      hooveredElement = this.mouseOverElement(pos);\n\n      if (hooveredElement !== -1) {\n         hooveredBead = this.uiElements[hooveredElement].ref;\n      }\n      if (oldHooveredElement !== hooveredElement) that.update();\n      oldPos = pos;\n      event.preventDefault();\n   }\n\n   getMouse(e) {\n      let element = this.canvas;\n      let offsetX = 0,\n         offsetY = 0,\n         mx,\n         my;\n\n      // compute the total offset\n      if (element.offsetParent !== undefined) {\n         do {\n            offsetX += element.offsetLeft;\n            offsetY += element.offsetTop;\n         } while ((element = element.offsetParent));\n      }\n\n      mx = e.pageX - offsetX;\n      my = e.pageY - offsetY;\n\n      return { x: mx, y: my };\n   }\n\n   render() {}\n}\n\nmodule.exports = Abacus;\n","const Bead = require('./bead');\n\nconst BEAD_WIDTH = 60;\nconst BEAD_HEIGHT = 40;\nconst BEAD_COLOR = \"rgba(133, 178, 255, 1.0)\";\nconst HOOVERED_BEAD_COLOR = \"rgba(170, 215, 255, 1.0)\";\n\nclass AbacusCtrl {\n\tconstructor(type, beadRods) {\n\t\tthis.type = type;\n\n\t\tthis.beadRods = beadRods; //column\n\t\tthis.beadPerRod = this.type === 0 ? 5 : 7;\n\t\tthis.beadSep = this.type === 0 ? 3 : 4;\n\t\tthis.beadSpacing = 80;\n\n\t\tthis.beadWidth = BEAD_WIDTH;\n\t\tthis.beadHeight = BEAD_HEIGHT;\n\t\t\n\t\tthis.beads = new Array();\n  \t};\n\n  \tinit() {\n\t\tthis.beads.length = 0;\n\t\tlet id = 0;\n\n\t\tfor (let i = 0; i < this.beadRods; i++) {\n\t\t\tfor (let j = 0; j < this.beadPerRod; j++) {\n\t\t\t\tlet bead = new Bead(BEAD_COLOR, BEAD_WIDTH, BEAD_HEIGHT, id);\n\t\t\t\tbead.posX = 580 - i * this.beadSpacing;\n\t\t\t\tbead.posY = 60 + this.beadPerRod * this.beadHeight - j * this.beadHeight;\n\t\t\t\tbead.value = 1; // do we need to create function here to set value?\t\t\t\t\n\t\t\t\tif (j > this.beadSep) {\n\t\t\t\t\tbead.posY =\n\t\t\t\t\t\t60 +\n\t\t\t\t\t\tthis.beadPerRod * this.beadHeight -\n\t\t\t\t\t\t(j * this.beadHeight + 2 * this.beadHeight);\n\t\t\t\t\tbead.value = 5;\n\t\t\t\t}\n\n\t\t\t\tbead.id = id;\n\t\t\t\tid++;\n\n\t\t\t\tthis.beads.push(bead);\n\t\t\t}\n\t\t}\n  \t};\n\n  \tgetBeadsCount() {\n   \treturn this.beads.length;\n  \t};\n\t  \n\tactivated(id) {\n\t\tlet rod = Math.floor(id / this.beadPerRod); // find the rod number\n\t\tlet beadInRod = id - rod * this.beadPerRod; // count beads at the bottom of selected bead\n\t\t\n\t\tlet active = this.beads[id].active;\n\t\tthis.beads[id].active = !active;\n\n\t\tlet dir = 1; // up or down\n\t\tif (beadInRod > this.beadSep) dir = -1;\n\n\t\tlet offset = dir * -1 * this.beads[id].height;\n\t\tif (active) offset = dir * this.beads[id].height;\n\t\tthis.beads[id].posY += offset;\n\n\t\tif (beadInRod <= this.beadSep) { // if bead is at the bottom deck\n\t\t\tfor (let j = 0; j < this.beadPerRod; j++) {\n\t\t\t\tlet n = rod * this.beadPerRod + j; // iterate through all beads under the selected bead, including that bead\n\t\t\t\tif (j <= this.beadSep && j !== beadInRod) { // if it's not the selected bead\n\t\t\t\t\tif ((!active && j > beadInRod) || (active && j < beadInRod)) {\n\t\t\t\t\t\tif (this.beads[n].active === active) {\n\t\t\t\t\t\t\tthis.beads[n].posY += offset;\n\t\t\t\t\t\t\tthis.beads[n].active = !this.beads[n].active;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (let j = 0; j < this.beadPerRod; j++) {\n\t\t\t\tlet n = rod * this.beadPerRod + j;\n\t\t\t\tif (j > this.beadSep && j !== beadInRod) {\n\t\t\t\t\tif ((!active && j < beadInRod) || (active && j > beadInRod)) {\n\t\t\t\t\t\tif (this.beads[n].active === active) {\n\t\t\t\t\t\t\tthis.beads[n].posY += offset;\n\t\t\t\t\t\t\tthis.beads[n].active = !this.beads[n].active;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\nmodule.exports = AbacusCtrl;","class Bead {\n   constructor(color, width, height, id) {\n      this.color = color;\n      this.posX = 0;\n      this.posY = 0;\n      this.value = 0;\n      this.width = width;\n      this.height = height;\n      this.id = id;\n      this.isActive = false;\n   }\n\n   elementUI(x, y, width, height, type, ref) {\n      this.x = x;\n      this.y = y;\n      this.x2 = x + width;\n      this.y2 = y + height;\n      this.type = type; // 0 = node, 1 = slot, 2 connection\n      this.ref = ref;\n   }\n\n   drawDiamond(ctx, x, y, width, height) {\n      ctx.save();\n      ctx.beginPath();\n      ctx.moveTo(x, y);\n\n      // top left edge\n      ctx.lineTo(x - width / 2, y + height / 2);\n\n      // bottom left edge\n      ctx.lineTo(x, y + height);\n\n      // bottom right edge\n      ctx.lineTo(x + width / 2, y + height / 2);\n\n      // closing the path automatically creates\n      // the top right edge\n      ctx.closePath();\n\n      ctx.fillStyle = \"red\";\n      ctx.fill();\n      ctx.restore();\n   }\n   //drawDiamond(context, canvas.width * 0.8, 70, 75, 100);\n\n   // draw the shape\n   drawRoundRectFilled(ctx, x, y, width, height, radius) {\n      let lineWidthBackup = ctx.lineWidth;\n      let strokeStyleBackup = ctx.strokeStyle;\n      ctx.strokeStyle = ctx.fillStyle;\n      ctx.lineJoin = \"round\";\n      ctx.lineWidth = radius;\n      ctx.strokeRect(\n         x + radius / 2,\n         y + radius / 2,\n         width - radius,\n         height - radius\n      );\n      ctx.fillRect(\n         x + radius / 2,\n         y + radius / 2,\n         width - radius,\n         height - radius\n      );\n      ctx.lineWidth = lineWidthBackup;\n      ctx.strokeStyle = strokeStyleBackup;\n   }\n\n   // draw(ctx) { // draw bead\n   //    let dn = this.elementUI(\n   //       this.x,\n   //       this.y + 2,\n   //       this.width,\n   //       this.height - 4,\n   //       0,\n   //       this.id\n   //    );\n\n   //    // draw the shadow\n   //    ctx.fillStyle = \"rgba(60, 60, 60, 0.3)\";\n   //    this.drawRoundRectFilled(\n   //       ctx,\n   //       dn.x + 4,\n   //       dn.y + 4,\n   //       dn.x2 - dn.x,\n   //       dn.y2 - dn.y,\n   //       15\n   //    );\n   //    ctx.fillStyle = beadColor;\n\n   //    if (this.isHoovered) {\n   //       ctx.fillStyle = HOOVERED_BEAD_COLOR;\n   //    }\n   //    // draw the shape\n   //    this.drawRoundRectFilled(ctx, dn.x, dn.y, dn.x2 - dn.x, dn.y2 - dn.y, 15); // draw the blue filling\n   //    ctx.fillStyle = \"rgba(255, 255, 255, 1.0)\";\n   // };\n}\n\nmodule.exports = Bead;\n","const Abacus = require('./abacus');\n\ndocument.addEventListener('DOMContentLoaded', () => {\n    let abacus = new Abacus('soroban', 0);\n    abacus.init();\n});","class UIElement {\n   constructor (x, y, width, height, type, ref) {\n      this.x = x;\n      this.y = y;\n      this.x2 = x + width;\n      this.y2 = y + height;\n      this.type = type; // 0 = node, 1 = slot, 2 connection\n      this.ref = ref;\n   }\n}\n\nmodule.exports = UIElement;\n"],"sourceRoot":""}